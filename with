#!/usr/bin/env groovy
import groovy.io.FileType
import org.apache.tools.ant.util.FileUtils

import static org.fusesource.jansi.Ansi.Attribute.INTENSITY_BOLD
import static org.fusesource.jansi.Ansi.Attribute.INTENSITY_BOLD_OFF
import static org.fusesource.jansi.Ansi.Color.RED
import static org.fusesource.jansi.Ansi.Color.GREEN
import static org.fusesource.jansi.Ansi.Color.YELLOW
import static org.fusesource.jansi.Ansi.Color.BLACK
import static org.fusesource.jansi.Ansi.ansi

new FrankenCover(args).doReport()

class FrankenCover
{

    public String[] args
    public CliBuilder cli

    public FrankenCover(String[] args)
    {
        super()
        this.args = args
        initCli()
    }

    public void doReport()
    {
        def opt = cli.parse(args)
        if (!opt) {
            System.exit(-1)
        }
        if (opt.h) {
            cli.usage()
        }


        String outPutDir = opt.getProperty("o") ? opt.getProperty("o") : "build/reports"
        String sourceDir = opt.getProperty("s")
        def reportConfig = new ReportConfig(directory: "${sourceDir}", excludeSymbols: 
            ["main.m", 
            "queue.h",
            "once.h",
            "CGGeometry.h", 
            "MKGeometry.h"])
            
        def ideConfig = new IDEConfig(withXcode: true, withAppCodeIfAvailable: true)
        if (opt.getProperty("x") || opt.getProperty("a")) {
            ideConfig.withAppCodeIfAvailable = opt.getProperty("a")
            ideConfig.withXcode = opt.getProperty("x")
        }

        Double requiredCoverage = opt.getProperty("r") ? new Double(opt.getProperty("r").replaceAll("%", "")) : 0
        def generator = new ReportGenerator(outPutDir, requiredCoverage, reportConfig, ideConfig, new AntBuilder())
        generator.generate()
        System.exit(generator.failed ? -1 : 0)
    }

    private void initCli()
    {
        def usageInstructions = """groovy http://frankencover.it/with -s <sourceDir> <options>\n\n
        |For instrunctions on configuring Xcode to output coverage data, visit http://frankencover.it\n\n
        """.stripMargin().stripIndent()
        cli = new CliBuilder(usage: usageInstructions)
        cli.with
                {
                    h(longOpt: 'help', 'Help - Usage Information')
                    s(longOpt: 'source-dir', 'The source directory to generate coverage for', args: 1, type: String, required: true)
                    o(longOpt: 'output-dir', 'The output directory to write coverage report', args: 1, type: String, required: false)
                    r(longOpt: 'required-coverage', 'Required line coverage', args: 1, type: String, required: false)
                    a(longOpt: 'appcode', 'Search in AppCode\'s output directory. (default is both Xcode and AppCode\'s output dirs)', args: 0, type: boolean, required: false)
                    x(longOpt: 'xcode', 'Search in Xcode\'s output directory. (default is both Xcode and AppCode\'s output dirs)', args: 0, type: boolean, required: false)
                    //e(longOpt: 'exclude', 'Comma separated list of symbols to exclude from report', args: 1, type: String, required: false)
                }
    }

}


class ReportGenerator
{
    String outputDir
    Double requiredCoverage
    ReportConfig reportConfig
    IDEConfig ideConfig
    AntBuilder ant

    boolean failed

    private File reportLocation

    // ================================================================ //
    // Constructors

    ReportGenerator(String outputDir, Double requiredCoverage, ReportConfig reportConfig, IDEConfig ideConfig, AntBuilder ant)
    {
        this.outputDir = outputDir
        this.requiredCoverage = requiredCoverage
        this.reportConfig = reportConfig
        this.ideConfig = ideConfig
        this.ant = ant
        this.reportLocation = new File("${outputDir}/coverage")

        print ansi().a(INTENSITY_BOLD)
        print ansi().fg(YELLOW).a("\nâ–¸ ")
        print ansi().fg(BLACK).a("Code Coverage:\n").reset()
    }

    // ================================================================ //
    // Public

    public void generate()
    {
        def collationDir = "${outputDir}/temp/coverage-data-collate"
        def coverageData = "${outputDir}/temp/coverage-data"
        def coverageInfoFile = "${outputDir}/temp/coverage.info"
        def genHtmlCmd = "genhtml --no-function-coverage --no-branch-coverage"
        def excludeSymbols = reportConfig.excludeSymbols.join(" ")

        def script = """\
            |#!/bin/sh
            |mkdir -p ${collationDir}
            |mkdir -p ${coverageData}
            |find ${ideConfig.searchDirectories()} ${reportConfig.dataFileNames()} | rsync --files-from=- / ${collationDir}
            |find ${collationDir} -type file -exec cp -fr {} ${coverageData} \\;
            |rm -fr ${collationDir}
            |geninfo ${coverageData}/*.gcno --no-recursion --output-filename ${coverageInfoFile}.temp
            |lcov -r ${coverageInfoFile}.temp ${excludeSymbols} > ${coverageInfoFile}
            |${genHtmlCmd} -o ${reportLocation.absolutePath} --prefix ${reportConfig.prefix()} ${coverageInfoFile}
            """.stripMargin()

//        println(script)

        Process process = "bash".execute();
        process.outputStream.write(script.getBytes())
        process.outputStream.close()

        process.waitFor()

        printSummary(coverageInfoFile)

    }

    private void printSummary(coverageInfoFile)
    {
        OutputStream os = new ByteArrayOutputStream()
        Process summary = "lcov --summary ${coverageInfoFile}".execute()
        summary.consumeProcessOutput(os, os)
        summary.waitFor()


        def parser = new ReportParser(os.toString())
        parser.print()

        if (parser.lineCoveragePercent < requiredCoverage) {
            print ansi().a(INTENSITY_BOLD).fg(RED).a("  <----- Required coverage is ${requiredCoverage}%\n").reset()
            failed = true
        }
        print ansi().a("\n").reset()
        print ansi().a("    ðŸ“Š  full report..: ${outputDir}/coverage/index.html")
        print ansi().a("\n\n").reset()
    }

}


class ReportParser
{

    Double lineCoveragePercent;
    String lineCoverageDetail;

    // ================================================================ //
    // Constructors

    ReportParser(String summary)
    {
        parse(summary);
    }

    // ================================================================ //
    // Public


    void print()
    {

        print ansi().a(INTENSITY_BOLD)
        if (lineCoveragePercent < 60) {
            print ansi().fg(RED).a("    âœ—").reset()
            print ansi().a("  lines........: ")
            print ansi().fg(RED)
        }
        else if (lineCoveragePercent < 79) {
            print ansi().fg(YELLOW).a("    âš ").reset()
            print ansi().a("  lines........: ")
        }
        else {
            print ansi().fg(GREEN).a("    âœ“ ").reset()
            print ansi().a("  lines........: ")
        }

        print ansi().a(INTENSITY_BOLD)
        print ansi().a("${lineCoveragePercent}% ").reset()
        print ansi().a("${lineCoverageDetail}")
    }

    // ================================================================ //
    // Private

    void parse(String summary)
    {
        boolean linesFound = false
        summary.eachLine {
            if (it.startsWith("  lines......:")) {
                def lineSummary = it.split("%")
                lineCoveragePercent = new Double(lineSummary[0].substring(15))
                lineCoverageDetail = lineSummary[1].trim()
                linesFound = true
            }
        }
        if (!linesFound) {
            throw new RuntimeException("Coverage data not found")
        }
    }
}

class ReportConfig
{

    String directory
    List<String> excludeSymbols

    //Private
    private List<String> fileNames;

    // ================================================================ //
    // Public


    String prefix()
    {
        def prefix
        if (directory.startsWith("/")) {
            prefix = directory
        }
        else {
            def baseDir = new File(".").getAbsolutePath()
            prefix = baseDir.substring(0, baseDir.length() - 1) + "${directory}"
        }
        return prefix
    }

    String dataFileNames()
    {
        def dataFiles = new ArrayList<String>();
        cachedFileNames().each { fileName ->
            dataFiles.add("-name ${fileName}.gcno")
            dataFiles.add("-name ${fileName}.gcda")
        }
        dataFiles.join(' -o ')
    }

    // ================================================================ //
    // Private

    private List<String> cachedFileNames()
    {
        if (!fileNames) {
            fileNames = new ArrayList<String>()

            def searchDir = directory.startsWith("/") ? new File(directory) : new File("./${directory}")

            searchDir.eachFileRecurse(FileType.FILES) { file ->
                def fileName = file.name;
                if (fileName.endsWith(".h")) {
                    fileNames << fileName.substring(0, fileName.length() - 2)
                }
            }
        }

        //println ("Filenames: " + fileNames)
        fileNames
    }


}

class IDEConfig
{

    public boolean withAppCodeIfAvailable
    public boolean withXcode

    def cachedAppCodeDir = null

    public String xcodeDir()
    {
        return "~/Library/Developer/Xcode/DerivedData"
    }

    public String appCodeDir()
    {
        if (cachedAppCodeDir == null) {
            def highestAppCodeInstalled = 0
            new File("${System.getProperty("user.home")}/Library/Caches").eachFile(FileType.DIRECTORIES) { directory ->
                def dir = directory.name;
                if (dir.startsWith("appCode")) {
                    def appCodeVersion = dir.replaceAll("[^\\d.]", "").toInteger()
                    highestAppCodeInstalled = appCodeVersion > highestAppCodeInstalled ? appCodeVersion : highestAppCodeInstalled
                }
            }
            if (highestAppCodeInstalled) {
                cachedAppCodeDir = "~/Library/Caches/appCode${highestAppCodeInstalled}"
            }
        }
        return cachedAppCodeDir
    }

    public String searchDirectories()
    {
        def searchDirectories = new StringBuilder()
        if (withXcode) {
            searchDirectories.append(xcodeDir())
            searchDirectories.append(" ")
        }
        if (withAppCodeIfAvailable && appCodeDir() != null) {
            searchDirectories.append(appCodeDir())
        }
        return searchDirectories.toString()
    }

}





